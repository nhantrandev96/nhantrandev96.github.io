{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function () {\n  var lastKnownScrollY = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n  var currentScrollY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  var state = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n  var scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';\n  var distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY); // We're disabled\n\n  if (props.disable) {\n    return {\n      action: 'none',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled // We're at the top and not fixed yet.\n\n    };\n  } else if (currentScrollY <= props.pinStart && state.state !== 'unfixed') {\n    return {\n      action: 'unfix',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled // We're unfixed and headed down. Carry on.\n\n    };\n  } else if (currentScrollY <= state.height && scrollDirection === 'down' && state.state === 'unfixed') {\n    return {\n      action: 'none',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n    };\n  } else if (currentScrollY > state.height + props.pinStart && scrollDirection === 'down' && state.state === 'unfixed') {\n    return {\n      action: 'unpin-snap',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled // We're past the header and scrolling down.\n      // We transition to \"unpinned\" if necessary.\n\n    };\n  } else if (scrollDirection === 'down' && ['pinned', 'unfixed'].indexOf(state.state) >= 0 && currentScrollY > state.height + props.pinStart && distanceScrolled > props.downTolerance) {\n    return {\n      action: 'unpin',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled // We're scrolling up, we transition to \"pinned\"\n\n    };\n  } else if (scrollDirection === 'up' && distanceScrolled > props.upTolerance && ['pinned', 'unfixed'].indexOf(state.state) < 0) {\n    return {\n      action: 'pin',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled // We're scrolling up, and inside the header.\n      // We transition to pin regardless of upTolerance\n\n    };\n  } else if (scrollDirection === 'up' && currentScrollY <= state.height && ['pinned', 'unfixed'].indexOf(state.state) < 0) {\n    return {\n      action: 'pin',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n    };\n  } else {\n    return {\n      action: 'none',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n    };\n  }\n};","map":{"version":3,"sources":["/Applications/XAMPP/xamppfiles/htdocs/nhantrandev96.github.io/node_modules/react-headroom/dist/shouldUpdate.js"],"names":["Object","defineProperty","exports","value","default","lastKnownScrollY","arguments","length","currentScrollY","props","state","scrollDirection","distanceScrolled","Math","abs","disable","action","pinStart","height","indexOf","downTolerance","upTolerance"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;;AAIAD,OAAO,CAACE,OAAR,GAAkB,YAAY;AAC5B,MAAIC,gBAAgB,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB,KAAK,CAA9C,GAAkDA,SAAS,CAAC,CAAD,CAA3D,GAAiE,CAAxF;AACA,MAAIE,cAAc,GAAGF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB,KAAK,CAA9C,GAAkDA,SAAS,CAAC,CAAD,CAA3D,GAAiE,CAAtF;AACA,MAAIG,KAAK,GAAGH,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB,KAAK,CAA9C,GAAkDA,SAAS,CAAC,CAAD,CAA3D,GAAiE,EAA7E;AACA,MAAII,KAAK,GAAGJ,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB,KAAK,CAA9C,GAAkDA,SAAS,CAAC,CAAD,CAA3D,GAAiE,EAA7E;AAEA,MAAIK,eAAe,GAAGH,cAAc,IAAIH,gBAAlB,GAAqC,MAArC,GAA8C,IAApE;AACA,MAAIO,gBAAgB,GAAGC,IAAI,CAACC,GAAL,CAASN,cAAc,GAAGH,gBAA1B,CAAvB,CAP4B,CAS5B;;AACA,MAAII,KAAK,CAACM,OAAV,EAAmB;AACjB,WAAO;AACLC,MAAAA,MAAM,EAAE,MADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA,gBAHb,CAIL;;AAJK,KAAP;AAMD,GAPD,MAOO,IAAIJ,cAAc,IAAIC,KAAK,CAACQ,QAAxB,IAAoCP,KAAK,CAACA,KAAN,KAAgB,SAAxD,EAAmE;AACxE,WAAO;AACLM,MAAAA,MAAM,EAAE,OADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA,gBAHb,CAIL;;AAJK,KAAP;AAMD,GAPM,MAOA,IAAIJ,cAAc,IAAIE,KAAK,CAACQ,MAAxB,IAAkCP,eAAe,KAAK,MAAtD,IAAgED,KAAK,CAACA,KAAN,KAAgB,SAApF,EAA+F;AACpG,WAAO;AACLM,MAAAA,MAAM,EAAE,MADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA;AAHb,KAAP;AAKD,GANM,MAMA,IAAIJ,cAAc,GAAGE,KAAK,CAACQ,MAAN,GAAeT,KAAK,CAACQ,QAAtC,IAAkDN,eAAe,KAAK,MAAtE,IAAgFD,KAAK,CAACA,KAAN,KAAgB,SAApG,EAA+G;AACpH,WAAO;AACLM,MAAAA,MAAM,EAAE,YADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA,gBAHb,CAIL;AACA;;AALK,KAAP;AAOD,GARM,MAQA,IAAID,eAAe,KAAK,MAApB,IAA8B,CAAC,QAAD,EAAW,SAAX,EAAsBQ,OAAtB,CAA8BT,KAAK,CAACA,KAApC,KAA8C,CAA5E,IAAiFF,cAAc,GAAGE,KAAK,CAACQ,MAAN,GAAeT,KAAK,CAACQ,QAAvH,IAAmIL,gBAAgB,GAAGH,KAAK,CAACW,aAAhK,EAA+K;AACpL,WAAO;AACLJ,MAAAA,MAAM,EAAE,OADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA,gBAHb,CAIL;;AAJK,KAAP;AAMD,GAPM,MAOA,IAAID,eAAe,KAAK,IAApB,IAA4BC,gBAAgB,GAAGH,KAAK,CAACY,WAArD,IAAoE,CAAC,QAAD,EAAW,SAAX,EAAsBF,OAAtB,CAA8BT,KAAK,CAACA,KAApC,IAA6C,CAArH,EAAwH;AAC7H,WAAO;AACLM,MAAAA,MAAM,EAAE,KADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA,gBAHb,CAIL;AACA;;AALK,KAAP;AAOD,GARM,MAQA,IAAID,eAAe,KAAK,IAApB,IAA4BH,cAAc,IAAIE,KAAK,CAACQ,MAApD,IAA8D,CAAC,QAAD,EAAW,SAAX,EAAsBC,OAAtB,CAA8BT,KAAK,CAACA,KAApC,IAA6C,CAA/G,EAAkH;AACvH,WAAO;AACLM,MAAAA,MAAM,EAAE,KADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA;AAHb,KAAP;AAKD,GANM,MAMA;AACL,WAAO;AACLI,MAAAA,MAAM,EAAE,MADH;AAELL,MAAAA,eAAe,EAAEA,eAFZ;AAGLC,MAAAA,gBAAgB,EAAEA;AAHb,KAAP;AAKD;AACF,CAlED","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function () {\n  var lastKnownScrollY = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n  var currentScrollY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  var state = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n\n  var scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';\n  var distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);\n\n  // We're disabled\n  if (props.disable) {\n    return {\n      action: 'none',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n      // We're at the top and not fixed yet.\n    };\n  } else if (currentScrollY <= props.pinStart && state.state !== 'unfixed') {\n    return {\n      action: 'unfix',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n      // We're unfixed and headed down. Carry on.\n    };\n  } else if (currentScrollY <= state.height && scrollDirection === 'down' && state.state === 'unfixed') {\n    return {\n      action: 'none',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n    };\n  } else if (currentScrollY > state.height + props.pinStart && scrollDirection === 'down' && state.state === 'unfixed') {\n    return {\n      action: 'unpin-snap',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n      // We're past the header and scrolling down.\n      // We transition to \"unpinned\" if necessary.\n    };\n  } else if (scrollDirection === 'down' && ['pinned', 'unfixed'].indexOf(state.state) >= 0 && currentScrollY > state.height + props.pinStart && distanceScrolled > props.downTolerance) {\n    return {\n      action: 'unpin',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n      // We're scrolling up, we transition to \"pinned\"\n    };\n  } else if (scrollDirection === 'up' && distanceScrolled > props.upTolerance && ['pinned', 'unfixed'].indexOf(state.state) < 0) {\n    return {\n      action: 'pin',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n      // We're scrolling up, and inside the header.\n      // We transition to pin regardless of upTolerance\n    };\n  } else if (scrollDirection === 'up' && currentScrollY <= state.height && ['pinned', 'unfixed'].indexOf(state.state) < 0) {\n    return {\n      action: 'pin',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n    };\n  } else {\n    return {\n      action: 'none',\n      scrollDirection: scrollDirection,\n      distanceScrolled: distanceScrolled\n    };\n  }\n};"]},"metadata":{},"sourceType":"script"}